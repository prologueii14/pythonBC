# -*- encoding: utf-8 -*-
"""
An implementation of the "An Efficient Double Parameter Elliptic Curve
Digital Signature Algorithm for Blockchain" (IEEE Access, 2021)
based on the structure of a standard ECDSA class.

This implementation follows the algorithm as described in Section IV
of the paper (Figure 1, Signature Generation, Signature Verification).

https://ieeexplore.ieee.org/document/9438692
"""

import hashlib
import secrets
from elliptic_curve import EllipticCurve


class DPECDSA:
    """
    Implements the Double Parameter ECDSA from the 2021 IEEE Access paper.
    
    This algorithm modifies standard ECDSA by:
    1. Using two random parameters (k1, k2) and a random k,
       bound by the equation k = k1*r + k2*e.
    2. Using the Hamming Weight (w) of the hash (e) in the signature
       equations instead of the hash (e) itself.
    3. Claiming to remove the modular inverse operations from the
       signature and verification processes.
    """
    
    def __init__(self, curve, G, n):
        """
        Initialize DPECDSA with curve parameters
        
        Args:
            curve: EllipticCurve instance
            G: Generator point (base point)
            n: Order of the generator point (number of points generated by G)
        """
        self.curve = curve
        self.G = G
        self.n = n  # Order of the subgroup generated by G
        
        # Verify G is on the curve
        if not curve.is_on_curve(G.x, G.y):
            raise ValueError("Generator point is not on the curve")
    
    def generate_keypair(self):
        """
        Generate a public-private key pair
        
        Returns:
            (private_key, public_key) where:
            - private_key: random integer in [1, n-1]
            - public_key: ECPoint = private_key * G
        """
        # Private key (d): random integer in [1, n-1]
        private_key = secrets.randbelow(self.n - 1) + 1
        
        # Public key: Q = d * G
        public_key = private_key * self.G
        
        return private_key, public_key
    
    def _hamming_weight(self, n):
        """
        Calculate the Hamming weight (number of '1's) of an integer's
        binary representation.
        """
        # A simple implementation: convert to binary string and count '1's
        return bin(n).count('1')

    def sign(self, message, private_key, hash_func=hashlib.sha3_256):
        """
        Sign a message using the Double Parameter ECDSA (DP-ECDSA)
        
        This follows Section IV. B. "SIGNATURE GENERATION"
        
        Args:
            message: bytes or string to sign
            private_key: integer private key (d)
            hash_func: hash function to use (default: SHA3-256)
        
        Returns:
            (r, s, k2): signature tuple
        """
        if isinstance(message, str):
            message = message.encode('utf-8')
        
        # Hash the message to get integer 'e'
        h_bytes = hash_func(message).digest()
        e = int.from_bytes(h_bytes, byteorder='big') % self.n
        
        # If e is 0, it's problematic for k2 calculation (no inverse)
        if e == 0:
            # Use a slightly different hash (e.g., append a null byte)
            h_bytes = hash_func(message + b'\x00').digest()
            e = int.from_bytes(h_bytes, byteorder='big') % self.n

        # Step 3 (Paper): Calculate hamming weight w
        w = self._hamming_weight(e)
        
        while True:
            # Step 1 (Paper): Select random k, calculate r
            k = secrets.randbelow(self.n - 1) + 1
            point = k * self.G
            r = point.x % self.n
            
            # If r = 0, re-select k
            if r == 0:
                continue
            
            # Step 2 (Paper): Select random k1
            # We must also calculate k2 to satisfy k = k1*r + k2*e
            # (Using e for m, as 'm' is ambiguous in the paper)
            k1 = secrets.randbelow(self.n - 1) + 1

            # *** NOTE on Paper Contradiction ***
            # To satisfy k = k1*r + k2*e, we must *calculate* k2.
            # k2 = (k - k1*r) * e^(-1) mod n
            # This requires a modular inverse (e_inv), which contradicts
            # the paper's claim of having "no inverse operation".
            # However, the verification logic *depends* on this equation.
            # We must implement it to create a valid signature.
            
            try:
                e_inv = self._mod_inverse(e, self.n)
            except ValueError:
                # This happens if e and n share a factor, which is
                # astronomically unlikely if n is prime.
                continue # Try with a new k

            k2 = ((k - k1 * r) * e_inv) % self.n
            
            # If k2 = 0, signature will be invalid. Re-select k, k1.
            if k2 == 0:
                continue

            # Step 4 (Paper): Calculate s
            # s = k1*r + (w + r)*d mod n
            s = (k1 * r + (w + r) * private_key) % self.n
            
            # If s = 0, re-select
            if s == 0:
                continue
                
            # Signature is (r, s, k2)
            return (r, s, k2)

    def verify(self, message, signature, public_key, hash_func=hashlib.sha3_256):
        """
        Verify a DP-ECDSA signature
        
        This follows Section IV. C. "SIGNATURE VERIFICATION"
        
        Args:
            message: bytes or string that was signed
            signature: (r, s, k2) signature tuple
            public_key: ECPoint public key (Q)
            hash_func: hash function used in signing
        
        Returns:
            True if signature is valid, False otherwise
        """
        try:
            r, s, k2 = signature
        except (TypeError, ValueError):
            return False
        
        # Step 1 (Paper): Verify signature values are in valid range
        if not (1 <= r < self.n) or not (1 <= s < self.n) or not (1 <= k2 < self.n):
            return False
        
        if isinstance(message, str):
            message = message.encode('utf-8')
        
        # Step 2 (Paper): Hash message, get e and w
        h_bytes = hash_func(message).digest()
        e = int.from_bytes(h_bytes, byteorder='big') % self.n
        
        # Re-check for e=0, which would have been handled in signing
        if e == 0:
            h_bytes = hash_func(message + b'\x00').digest()
            e = int.from_bytes(h_bytes, byteorder='big') % self.n
            
        w = self._hamming_weight(e)
        
        # Step 3 (Paper): Compute v and u
        # v = (s + k2*m) mod n  (using e for m)
        v = (s + k2 * e) % self.n
        
        # u = (w + r) mod n
        u = (w + r) % self.n
        
        # If u or v resulted in 0 (highly unlikely but possible)
        if v == 0 or u == 0:
            return False

        # Step 4 (Paper): Compute point (x', y') = v*G - u*Q
        # This is equivalent to v*G + (-u)*Q
        
        # We calculate (-u) mod n
        u_neg = (-u) % self.n
        
        # Calculate point (x', y') = v*G + (-u)*Q
        point = v * self.G + u_neg * public_key
        
        # If point is infinity, signature is invalid
        if point.is_infinity():
            return False
        
        # Step 5 (Paper): Compute r' = x' mod n and check
        r_prime = point.x % self.n
        return r == r_prime

    def _mod_inverse(self, a, m):
        """
        Calculate modular multiplicative inverse using Extended Euclidean Algorithm
        Returns: a^(-1) mod m
        
        This function is still required to calculate k2 during signing,
        despite the paper's claims of an "inverse-free" algorithm.
        """
        def extended_gcd(a, b):
            if a == 0:
                return b, 0, 1
            gcd, x1, y1 = extended_gcd(b % a, a)
            x = y1 - (b // a) * x1
            y = x1
            return gcd, x, y
        
        gcd, x, _ = extended_gcd(a % m, m)
        if gcd != 1:
            raise ValueError(f"{a} has no modular inverse mod {m}")
        return (x % m + m) % m

class StandardCurves:
    """Standard elliptic curves for DPECDSA"""
    
    @staticmethod
    def secp256k1():
        """
        Bitcoin's secp256k1 curve
        https://en.bitcoin.it/wiki/Secp256k1
        """
        # Curve parameters
        p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F # 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
        a = 0
        b = 7
        
        curve = EllipticCurve(a, b, p)
        
        # Generator point G
        Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
        Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
        G = curve.ECPoint(Gx, Gy)
        
        # Order of G
        n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
        
        return DPECDSA(curve, G, n)
    
    @staticmethod
    def secp256r1():
        """
        NIST P-256 curve (also known as prime256v1)
        y^2 = x^3 - 3x + b (mod p)
        """
        p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF
        a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC
        b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B
        
        curve = EllipticCurve(a, b, p)
        
        # Generator point G
        Gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296
        Gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5
        G = curve.ECPoint(Gx, Gy)
        
        # Order of G
        n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551
        
        return DPECDSA(curve, G, n)

def demonstrate_dpecdsa():
    """Demonstrate DPECDSA signing and verification"""
    print("=== DPECDSA Signing and Verification Demo ===")

    def secp256k1_demo():
        """Demonstrate DPECDSA with secp256k1 curve (Bitcoin's curve)"""
        print("\n[ Demo 1: Using secp256k1 (Bitcoin Curve) ]")
        print("-" * 50)
        
        dpecdsa_secp256k1 = StandardCurves.secp256k1()
        print(f"Curve: y^2 = x^3 + 7 (mod p)")
        print(f"Prime p bit length: {dpecdsa_secp256k1.curve.p.bit_length()} bits")
        
        # Generate key pair
        private_key, public_key = dpecdsa_secp256k1.generate_keypair()
        print(f"\nPrivate Key: {private_key}")
        print(f"Public Key:")
        print(f"  x = {hex(public_key.x)}")
        print(f"  y = {hex(public_key.y)}")
        
        # Sign a message
        message = "Bitcoin transaction: Send 1 BTC to Alice"
        print(f"\nOriginal Message: {message}")
        
        # --- FIX 2: Signature is (r, s, k2) ---
        signature = dpecdsa_secp256k1.sign(message, private_key)
        r, s, k2 = signature
        print(f"\nSignature (r, s, k2):")
        print(f"  r = {hex(r)}")
        print(f"  s = {hex(s)}")
        print(f"  k2 = {hex(k2)}")
        
        # Verify signature
        is_valid = dpecdsa_secp256k1.verify(message, signature, public_key)
        print(f"\nSignature Verification: {'Valid' if is_valid else 'Invalid'}")
        
        # Test with tampered message
        tampered_message = "Bitcoin transaction: Send 100 BTC to Alice"
        is_valid = dpecdsa_secp256k1.verify(tampered_message, signature, public_key)
        print(f"Tampered Message Verification: {'Valid' if is_valid else 'Invalid'}")
    
    def secp256r1_demo():
        """Demonstrate DPECDSA with secp256r1 curve (NIST P-256)"""
        print("\n\n[ Demo 2: Using secp256r1 (NIST P-256) ]")
        print("-" * 50)
        
        dpecdsa_secp256r1 = StandardCurves.secp256r1()
        print(f"Curve: NIST P-256")
        print(f"Prime p bit length: {dpecdsa_secp256r1.curve.p.bit_length()} bits")
        
        # Generate key pair
        private_key, public_key = dpecdsa_secp256r1.generate_keypair()
        print(f"\nPrivate Key: {private_key}")
        print(f"Public Key: (truncated)")
        print(f"  x = {hex(public_key.x)[:50]}...")
        print(f"  y = {hex(public_key.y)[:50]}...")
        
        # Sign a message
        message = "Important document signature"
        # --- FIX 5: Signature is (r, s, k2) ---
        signature = dpecdsa_secp256r1.sign(message, private_key)
        r, s, k2 = signature
        print(f"\nMessage: {message}")
        print(f"Signature (r, s, k2): (truncated)")
        print(f"  r = {hex(r)[:50]}...")
        print(f"  s = {hex(s)[:50]}...")
        print(f"  k2 = {hex(k2)[:50]}...")
        
        # Verify signature
        is_valid = dpecdsa_secp256r1.verify(message, signature, public_key)
        print(f"\nSignature Verification: {'Valid' if is_valid else 'Invalid'}")

        # Test with tampered message
        tampered_message = "Important document signature altered"
        is_valid = dpecdsa_secp256r1.verify(tampered_message, signature, public_key)
        print(f"Tampered Message Verification: {'Valid' if is_valid else 'Invalid'}")

    try:
        #small_curve_demo() # Commented out as it requires a specific `order` method
        secp256k1_demo()
        secp256r1_demo()
    except ImportError:
        print("\n" + "="*50)
        print("ERROR: Could not import `EllipticCurve`.")
        print("Please ensure the file 'elliptic_curve.py' is in the same directory.")
        print("="*50)
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("This might be due to the missing 'elliptic_curve.py' file or its contents.")


if __name__ == "__main__":
    demonstrate_dpecdsa()