# -*- encoding: utf-8 -*-
"""
ECDSA (Elliptic Curve Digital Signature Algorithm) Implementation
Based on elliptic_curve.py
"""

import hashlib
import secrets
import hmac
import base64
from elliptic_curve import *


class ECDSA:
    """ECDSA Digital Signature Algorithm"""

    def __init__(self, curve, G, n):
        """
        Initialize ECDSA with curve parameters

        Args:
            curve: EllipticCurve instance
            G: Generator point (base point)
            n: Order of the generator point (number of points generated by G)
        """
        self.curve = curve
        self.G = G
        self.n = n  # Order of the subgroup generated by G

        # Verify G is on the curve
        if not curve.is_on_curve(G.x, G.y):
            raise ValueError("Generator point is not on the curve")

    def generate_keypair(self):
        """
        Generate a public-private key pair

        Returns:
            (private_key, public_key) where:
            - private_key: random integer in [1, n-1]
            - public_key: ECPoint = private_key * G
        """
        # Private key: random integer in [1, n-1]
        private_key = secrets.randbelow(self.n - 1) + 1

        # Public key: Q = d * G
        public_key = private_key * self.G

        return private_key, public_key

    def sign(self, message, private_key, hash_func=hashlib.sha256, deterministic=True):
        """
        Sign a message using ECDSA

        Args:
            message: bytes or string to sign
            private_key: integer private key
            hash_func: hash function to use (default: SHA-256)
            deterministic: if True, use RFC 6979 deterministic k generation

        Returns:
            (r, s): signature tuple
        """
        # Convert message to bytes if necessary
        if isinstance(message, str):
            message = message.encode('utf-8')

        # Hash the message
        e = int.from_bytes(hash_func(message).digest(), byteorder='big')

        # Truncate hash if necessary (take leftmost bits)
        z = e % self.n

        if deterministic:
            # Use RFC 6979 to generate deterministic k
            k = self._generate_k_rfc6979(z, private_key, hash_func)
        else:
            # Use random k (original ECDSA)
            k = secrets.randbelow(self.n - 1) + 1

        while True:
            # Calculate point kG = (x1, y1)
            point = k * self.G

            # r = x1 mod n
            r = point.x % self.n

            # If r = 0, try again (should never happen with RFC 6979)
            if r == 0:
                if deterministic:
                    raise ValueError("RFC 6979 generated invalid k (r=0)")
                k = secrets.randbelow(self.n - 1) + 1
                continue

            # Calculate s = k^(-1) * (z + r * private_key) mod n
            k_inv = self._mod_inverse(k, self.n)
            s = (k_inv * (z + r * private_key)) % self.n

            # If s = 0, try again (should never happen with RFC 6979)
            if s == 0:
                if deterministic:
                    raise ValueError("RFC 6979 generated invalid k (s=0)")
                k = secrets.randbelow(self.n - 1) + 1
                continue

            return (r, s)

    def verify(self, message, signature, public_key, hash_func=hashlib.sha256):
        """
        Verify an ECDSA signature

        Args:
            message: bytes or string that was signed
            signature: (r, s) signature tuple
            public_key: ECPoint public key
            hash_func: hash function used in signing

        Returns:
            True if signature is valid, False otherwise
        """
        r, s = signature

        # Verify signature values are in valid range
        if not (1 <= r < self.n) or not (1 <= s < self.n):
            return False

        # Convert message to bytes if necessary
        if isinstance(message, str):
            message = message.encode('utf-8')

        # Hash the message
        e = int.from_bytes(hash_func(message).digest(), byteorder='big')
        z = e % self.n

        # Calculate w = s^(-1) mod n
        w = self._mod_inverse(s, self.n)

        # Calculate u1 = z * w mod n
        u1 = (z * w) % self.n

        # Calculate u2 = r * w mod n
        u2 = (r * w) % self.n

        # Calculate point (x1, y1) = u1 * G + u2 * public_key
        point = u1 * self.G + u2 * public_key

        # If point is infinity, signature is invalid
        if point.is_infinity():
            return False

        # Verify r = x1 mod n
        return r == (point.x % self.n)

    def _mod_inverse(self, a, m):
        """
        Calculate modular multiplicative inverse using Extended Euclidean Algorithm
        Returns: a^(-1) mod m
        """
        def extended_gcd(a, b):
            if a == 0:
                return b, 0, 1
            gcd, x1, y1 = extended_gcd(b % a, a)
            x = y1 - (b // a) * x1
            y = x1
            return gcd, x, y

        gcd, x, _ = extended_gcd(a % m, m)
        if gcd != 1:
            raise ValueError(f"{a} has no modular inverse mod {m}")
        return (x % m + m) % m

    def _generate_k_rfc6979(self, z, private_key, hash_func):
        """
        Generate deterministic k value according to RFC 6979

        Args:
            z: hash of message (integer)
            private_key: private key (integer)
            hash_func: hash function used

        Returns:
            k: deterministic nonce for ECDSA signing
        """
        # Get hash output length in bytes
        hash_len = hash_func().digest_size

        # Convert integers to bytes with proper length
        # qlen is the binary length of n
        qlen = self.n.bit_length()
        # rlen is hash output length in bits
        rlen = hash_len * 8

        # Step a: h1 = H(m) already computed as z
        # Convert z to bytes (big-endian, length = hash_len)
        h1 = z.to_bytes(hash_len, byteorder='big')

        # Step b: Convert private key to bytes
        # x must be qlen bits long
        x = private_key.to_bytes((qlen + 7) // 8, byteorder='big')

        # Step c: Initialize V to 0x01 0x01 0x01 ... 0x01
        V = b'\x01' * hash_len

        # Step d: Initialize K to 0x00 0x00 0x00 ... 0x00
        K = b'\x00' * hash_len

        # Step e: K = HMAC_K(V || 0x00 || x || h1)
        K = hmac.new(K, V + b'\x00' + x + h1, hash_func).digest()

        # Step f: V = HMAC_K(V)
        V = hmac.new(K, V, hash_func).digest()

        # Step g: K = HMAC_K(V || 0x01 || x || h1)
        K = hmac.new(K, V + b'\x01' + x + h1, hash_func).digest()

        # Step h: V = HMAC_K(V)
        V = hmac.new(K, V, hash_func).digest()

        # Step h: Generate k
        while True:
            # Step h1: Set T to empty sequence
            T = b''

            # Step h2: While tlen < qlen
            while len(T) * 8 < qlen:
                V = hmac.new(K, V, hash_func).digest()
                T = T + V

            # Step h3: Compute k from T
            k = int.from_bytes(T, byteorder='big')
            k = k >> (len(T) * 8 - qlen)  # Take leftmost qlen bits

            # Check if k is in valid range [1, n-1]
            if 1 <= k < self.n:
                return k

            # If k is not valid, update K and V and try again
            K = hmac.new(K, V + b'\x00', hash_func).digest()
            V = hmac.new(K, V, hash_func).digest()

    def serialize_private_key(self, private_key):
        """
        Serialize private key to Base64 string.

        Args:
            private_key: integer private key

        Returns:
            Base64 encoded private key string
        """
        # Convert to bytes with proper length (32 bytes for 256-bit keys)
        key_bytes = private_key.to_bytes(32, byteorder='big')
        return base64.b64encode(key_bytes).decode('utf-8')

    def deserialize_private_key(self, encoded_key):
        """
        Deserialize private key from Base64 string.

        Args:
            encoded_key: Base64 encoded private key string

        Returns:
            integer private key
        """
        key_bytes = base64.b64decode(encoded_key.encode('utf-8'))
        return int.from_bytes(key_bytes, byteorder='big')

    def serialize_public_key(self, public_key):
        """
        Serialize public key to Base64 string (uncompressed format).

        Args:
            public_key: ECPoint public key

        Returns:
            Base64 encoded public key string
        """
        # Uncompressed format: 0x04 + x (32 bytes) + y (32 bytes)
        x_bytes = public_key.x.to_bytes(32, byteorder='big')
        y_bytes = public_key.y.to_bytes(32, byteorder='big')
        key_bytes = b'\x04' + x_bytes + y_bytes
        return base64.b64encode(key_bytes).decode('utf-8')

    def deserialize_public_key(self, encoded_key):
        """
        Deserialize public key from Base64 string.

        Args:
            encoded_key: Base64 encoded public key string

        Returns:
            ECPoint public key
        """
        key_bytes = base64.b64decode(encoded_key.encode('utf-8'))

        if len(key_bytes) != 65 or key_bytes[0] != 0x04:
            raise ValueError("Invalid public key format")

        x = int.from_bytes(key_bytes[1:33], byteorder='big')
        y = int.from_bytes(key_bytes[33:65], byteorder='big')

        return self.curve.ECPoint(x, y)

    def serialize_signature(self, signature):
        """
        Serialize signature to Base64 string.

        Args:
            signature: (r, s) tuple

        Returns:
            Base64 encoded signature string
        """
        r, s = signature
        # Each component is 32 bytes for 256-bit curves
        r_bytes = r.to_bytes(32, byteorder='big')
        s_bytes = s.to_bytes(32, byteorder='big')
        sig_bytes = r_bytes + s_bytes
        return base64.b64encode(sig_bytes).decode('utf-8')

    def deserialize_signature(self, encoded_signature):
        """
        Deserialize signature from Base64 string.

        Args:
            encoded_signature: Base64 encoded signature string

        Returns:
            (r, s) signature tuple
        """
        sig_bytes = base64.b64decode(encoded_signature.encode('utf-8'))

        if len(sig_bytes) != 64:
            raise ValueError("Invalid signature format")

        r = int.from_bytes(sig_bytes[:32], byteorder='big')
        s = int.from_bytes(sig_bytes[32:64], byteorder='big')

        return (r, s)


# Standard curve parameters
class StandardCurves:
    """Standard elliptic curves for ECDSA"""

    @staticmethod
    def secp256k1():
        """
        Bitcoin's secp256k1 curve
        y^2 = x^3 + 7 (mod p)
        """
        # Curve parameters
        p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
        a = 0
        b = 7

        # Generator point G
        Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
        Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8

        # Order of G
        n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

        curve = EllipticCurve(a, b, p)
        G = curve.ECPoint(Gx, Gy)

        return ECDSA(curve, G, n)

    @staticmethod
    def secp256r1():
        """
        NIST P-256 curve (also known as prime256v1)
        y^2 = x^3 - 3x + b (mod p)
        """
        p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF
        a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC
        b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B

        Gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296
        Gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5

        n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

        curve = EllipticCurve(a, b, p)
        G = curve.ECPoint(Gx, Gy)

        return ECDSA(curve, G, n)


def demonstrate_ecdsa():
    """Demonstrate ECDSA signing and verification"""
    print("=== ECDSA Signing and Verification Demo ===\n")

    # Method 1: Using a small curve for demonstration
    print("[ Demo 1: Using Small Curve ]")
    print("-" * 50)

    # Small curve for demonstration
    p = 223
    a = 0
    b = 7

    curve = EllipticCurve(a, b, p)
    print(f"{curve}")

    # Generator point
    Gx, Gy = 47, 71
    G = curve.ECPoint(Gx, Gy)
    n = 223  # Simplified (in practice, calculate the actual order)

    ecdsa = ECDSA(curve, G, n)

    # Generate key pair
    private_key, public_key = ecdsa.generate_keypair()
    print(f"\nPrivate Key: {private_key}")
    print(f"Public Key: {public_key}")

    # Sign a message
    message = "Hello, ECDSA!"
    print(f"\nOriginal Message: {message}")

    signature = ecdsa.sign(message, private_key)
    r, s = signature
    print(f"Signature (r, s):")
    print(f"  r = {r}")
    print(f"  s = {s}")

    # Verify signature
    is_valid = ecdsa.verify(message, signature, public_key)
    print(f"\nSignature Verification: {'Valid' if is_valid else 'Invalid'}")

    # Test with tampered message
    tampered_message = "Hello, ECDSA?"
    is_valid = ecdsa.verify(tampered_message, signature, public_key)
    print(f"Tampered Message Verification: {'Valid' if is_valid else 'Invalid'}")

    # Method 2: Using secp256k1 (Bitcoin's curve)
    print("\n\n[ Demo 2: Using secp256k1 (Bitcoin Curve) with RFC 6979 ]")
    print("-" * 50)

    ecdsa_secp256k1 = StandardCurves.secp256k1()
    print(f"Curve: y^2 = x^3 + 7 (mod p)")
    print(f"Prime p bit length: {ecdsa_secp256k1.curve.p.bit_length()} bits")

    # Generate key pair
    private_key, public_key = ecdsa_secp256k1.generate_keypair()
    print(f"\nPrivate Key: {private_key}")
    print(f"Public Key:")
    print(f"  x = {hex(public_key.x)}")
    print(f"  y = {hex(public_key.y)}")

    # Sign a message with RFC 6979
    message = "Bitcoin transaction: Send 1 BTC to Alice"
    print(f"\nOriginal Message: {message}")

    signature = ecdsa_secp256k1.sign(message, private_key, deterministic=True)
    r, s = signature
    print(f"\nSignature (r, s) - RFC 6979:")
    print(f"  r = {hex(r)}")
    print(f"  s = {hex(s)}")

    # Verify signature
    is_valid = ecdsa_secp256k1.verify(message, signature, public_key)
    print(f"\nSignature Verification: {'Valid' if is_valid else 'Invalid'}")

    # Test determinism
    print(f"\n--- Testing Determinism ---")
    signature2 = ecdsa_secp256k1.sign(message, private_key, deterministic=True)
    print(f"Deterministic Signatures Match: {signature == signature2}")

    # Test with tampered message
    tampered_message = "Bitcoin transaction: Send 100 BTC to Alice"
    is_valid = ecdsa_secp256k1.verify(tampered_message, signature, public_key)
    print(f"Tampered Message Verification: {'Valid' if is_valid else 'Invalid'}")

    # Method 3: Using secp256r1 (NIST P-256)
    print("\n\n[ Demo 3: Using secp256r1 (NIST P-256) ]")
    print("-" * 50)

    ecdsa_secp256r1 = StandardCurves.secp256r1()
    print(f"Curve: NIST P-256")
    print(f"Prime p bit length: {ecdsa_secp256r1.curve.p.bit_length()} bits")

    # Generate key pair
    private_key, public_key = ecdsa_secp256r1.generate_keypair()
    print(f"\nPrivate Key: {private_key}")
    print(f"Public Key: (truncated)")
    print(f"  x = {hex(public_key.x)[:50]}...")
    print(f"  y = {hex(public_key.y)[:50]}...")

    # Sign a message
    message = "Important document signature"
    signature = ecdsa_secp256r1.sign(message, private_key)
    r, s = signature
    print(f"\nMessage: {message}")
    print(f"Signature (r, s): (truncated)")
    print(f"  r = {hex(r)[:50]}...")
    print(f"  s = {hex(s)[:50]}...")

    # Verify signature
    is_valid = ecdsa_secp256r1.verify(message, signature, public_key)
    print(f"\nSignature Verification: {'Valid' if is_valid else 'Invalid'}")

    # Performance test
    print("\n\n[ Performance Test ]")
    print("-" * 50)
    import time

    iterations = 10

    # Use secp256k1 for performance test
    perf_message = "Performance test message"
    perf_private_key, perf_public_key = ecdsa_secp256k1.generate_keypair()
    perf_signature = ecdsa_secp256k1.sign(perf_message, perf_private_key, deterministic=True)

    # Test signing
    start = time.time()
    for _ in range(iterations):
        ecdsa_secp256k1.sign(perf_message, perf_private_key, deterministic=True)
    sign_time = (time.time() - start) / iterations

    # Test verification
    start = time.time()
    for _ in range(iterations):
        ecdsa_secp256k1.verify(perf_message, perf_signature, perf_public_key)
    verify_time = (time.time() - start) / iterations

    print(f"Average Signing Time: {sign_time*1000:.2f} ms")
    print(f"Average Verification Time: {verify_time*1000:.2f} ms")


if __name__ == "__main__":
    demonstrate_ecdsa()
